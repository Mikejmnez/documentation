
<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<title>BES Aggregation - OPeNDAP Documentation</title>
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-BES_Aggregation skin-monobook action-view">
<div id="globalWrapper">
<div id="column-content"><div id="content" class="mw-body-primary" role="main">
	
	
	<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">BES Aggregation</span></h1>
	<div id="bodyContent" class="mw-body">
		<div id="siteSub">From OPeNDAP Documentation</div>
		<div id="contentSub"></div>
		

		<!-- start content -->
<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p>By default there are no aggregation engines installed with the BES. But there is a mechanism to register your own aggregation engine. This page will discuss how to go about doing that.
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#How_does_aggregation_work_in_the_BES.3F"><span class="tocnumber">1</span> <span class="toctext">How does aggregation work in the BES?</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Creating_your_Aggregation_Handler"><span class="tocnumber">2</span> <span class="toctext">Creating your Aggregation Handler</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Registering_your_Aggregation_Handler"><span class="tocnumber">3</span> <span class="toctext">Registering your Aggregation Handler</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Writing_your_aggregate_method"><span class="tocnumber">4</span> <span class="toctext">Writing your aggregate method</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Summary"><span class="tocnumber">5</span> <span class="toctext">Summary</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="How_does_aggregation_work_in_the_BES.3F"><span class="mw-headline-number">1</span> How does aggregation work in the BES?</span></h2>
<p>A request comes into the BES that references some containers, creates a definition using those containers adding constraints and specifying an aggregation engine to use and an aggregation command, and then a get command to grab the containers, constrain them, and then aggregate. The command would look something like this:
</p>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;request reqID=&quot;some_unique_value&quot; &gt;
    &lt;setContainer name=&quot;c1&quot; space=&quot;catalog&quot;&gt;/data/nc/fnoc1.nc&lt;/setContainer&gt;
    &lt;setContainer name=&quot;c2&quot; space=&quot;catalog&quot;&gt;/data/nc/fnoc2.nc&lt;/setContainer&gt;
    &lt;setContainer name=&quot;c3&quot; space=&quot;catalog&quot;&gt;/data/nc/fnoc3.nc&lt;/setContainer&gt;
    &lt;setContainer name=&quot;c4&quot; space=&quot;catalog&quot;&gt;/data/nc/fnoc4.nc&lt;/setContainer&gt;
    &lt;define name=&quot;d&quot;&gt;
	&lt;container name=&quot;c1&quot;&gt;
            &lt;constraint&gt;u&lt;/constraint&gt;
        &lt;/container&gt;
	&lt;container name=&quot;c2&quot;&gt;
            &lt;constraint&gt;u&lt;/constraint&gt;
        &lt;/container&gt;
	&lt;container name=&quot;c3&quot;&gt;
            &lt;constraint&gt;u&lt;/constraint&gt;
        &lt;/container&gt;
	&lt;container name=&quot;c4&quot;&gt;
            &lt;constraint&gt;u&lt;/constraint&gt;
        &lt;/container&gt;
        &lt;aggregate handler=&quot;someHandler&quot; cmd=&quot;someCommand&quot; /&gt;
    &lt;/define&gt;
    &lt;get type=&quot;dods&quot; definition=&quot;d&quot; /&gt;
&lt;/request&gt;
</pre>
<p>In order to the BES to perform the specified aggregation there must be an aggregation engine registered with the BES call <code>someHandler</code>. The command <code>cmd</code> is passed to the aggregation engine and is parsed by the engine. This command can be different from engine to engine, there are no requirements for the command.
</p>
<h2><span class="mw-headline" id="Creating_your_Aggregation_Handler"><span class="mw-headline-number">2</span> Creating your Aggregation Handler</span></h2>
<p>The first step is to create an aggregation class that inherits from BESAggregationServer. The minimum that must be defined in this new class is the following:
</p>
<pre>
class MyAggregationServer&#160;: public BESAggregationServer
{
public:
                       MyAggregationServer( string handler_name )
                             &#160;: BESAggregationServer( handler_name ) {}&#160;;
    virtual            ~MyAggregationServer() {}&#160;;

    virtual void       aggregate( BESDataHandlerInterface &amp;dhi )&#160;;

    static BESAggregationServer *AggBuilder( string handler_name );
};
</pre>
<p>The value of the handler_name parameter will be <code>someHandler</code>. When a request comes in to aggregate, the BES takes that name and looks up a function in the aggregation factory with that name (someHandler) and calls that function. That function will return a new instance of BESAggregationServer. The function called will be AggBuilder. The function AggBuilder would look something liket his:
</p>
<pre>
BESAggregationServer *
MyAggregationServer::AggBuilder( string handler_name )
{
    return new MyAggregationServer( handler_name )&#160;;
}
</pre>
<p>The only real method that you have to implement is the aggregate method. More on that later.
</p>
<h2><span class="mw-headline" id="Registering_your_Aggregation_Handler"><span class="mw-headline-number">3</span> Registering your Aggregation Handler</span></h2>
<p>You register your new aggregation handler with the Aggregation Factory BESAggFactory giving it the name that you want it to be referenced by in the define command (someHandler). What you are actually registering with the factory is a function that knows how to instantiate the new aggregation server. In the example above, MyAggregationServer::AggBuilder function is registered with the BESAggFactory. This should be done in your Module class' initialize method.
</p><p>For example:
</p>
<pre>
    BESDEBUG( &quot;mydebug&quot;, &quot;    adding &quot; &lt;&lt; modname &lt;&lt; &quot; aggregation&quot; &lt;&lt; endl )
    BESAggFactory::TheFactory()-&gt;add_handler( modname, MyAggregationServer::AggBuilder )&#160;;
</pre>
<p>Typically, the name of the aggregation engine is the same as the name of your module. In this example, modname would be "someHandler".
</p>
<h2><span class="mw-headline" id="Writing_your_aggregate_method"><span class="mw-headline-number">4</span> Writing your <code>aggregate</code> method</span></h2>
<p>The aggregate method is the only method that you need to implement. This is the method that gets called to aggregate the resulting DataDDS object. The DataDDS object is stored in the BESDataHandlerInterface instance passed to your method. Here is an example of getting the DataDDS out of the BESDataHandlerInterface.
</p>
<pre>
void
NCESGAggregationServer::aggregate( BESDataHandlerInterface &amp;dhi )
{
    if( dhi.action == &quot;das&quot; )
    {
        string err = &quot;DAS is not a valid request type in aggregated datasets&quot;&#160;;
        throw BESInternalError( err, __FILE__, __LINE__ )&#160;;
    }

    BESResponseObject *resp = dhi.response_handler-&gt;get_response_object()&#160;;
    BESDataDDSResponse *bdds = dynamic_cast&lt;BESDataDDSResponse *&gt;(resp)&#160;;
    if(&#160;!bdds )
    {
        string err = &quot;response object is not a DataDDS&quot;&#160;;
        throw BESInternalError( err, __FILE__, __LINE__ )&#160;;
    }
    DataDDS *dds = bdds-&gt;get_dds()&#160;;
    if(&#160;!dds )
    {
        string err = &quot;dap response object is not a DataDDS&quot;&#160;;
        throw BESInternalError( err, __FILE__, __LINE__ )&#160;;
    }

    ....
    your code here
    .....
</pre>
<p>Once you have the DataDDS you have all of the data that has been read in and you can perform your aggregation. The DataDDS will be organized in the following manner. For each of the containers defined in the BES request (in our example, c1, c2, c3, and c4) there will be a structure containing the data for that container. So, in our example, you would have:
</p>
<pre>
Dataset {
    Structure {
        Int16 u[time_a = 16][lat = 17][lon = 21];
    } c1;
    Structure {
        Int16 u[time_a = 16][lat = 17][lon = 21];
    } c2;
    Structure {
        Int16 u[time_a = 16][lat = 17][lon = 21];
    } c3;
    Structure {
        Int16 u[time_a = 16][lat = 17][lon = 21];
    } c4;
} fnoc1.nc;
</pre>
<p>The result of your aggregation will be a new DataDDS object that will take the place of the one you got out. The end of your function might look something like this:
</p>
<pre>
    ....
    your code here
    ...
    BESDataDDSResponse *my_bdata = new BESDataDDSResponse( my_data )&#160;;
    dhi.response_handler-&gt;set_response_object( my_bdata )&#160;;
    delete bdds&#160;;
}
</pre>
<h2><span class="mw-headline" id="Summary"><span class="mw-headline-number">5</span> Summary</span></h2>
<p>We recommend that your first step in writing your own aggregation server is to create the classes that you will need with an empty <code>aggregate</code> method, get it compiled and installed, load the module into the BES, and make sure that your aggregation method is being called. Once you have done this, then you can write your <code>aggregate</code> method.
</p><p>Here's what you need to do:
</p>
<ol>
<li> Create your class that inherits from BESAggregationServer using the code from above.
</li>
<li> Register your AggBuilder function with the BESAggFactory in your Module class.
</li>
<li> Build your new code, creating a shared object library (.so file) that can be loaded into the BES
</li>
<li> Add your module to the BES configuration file
</li>
<li> Run the BES with this new module
</li>
<li> Implement your <code>aggregate</code> method
</li>
</ol>
<p>For more information on the Module class and adding it to the BES configuration file, please refer to the <a href="../index.php/Hyrax_-_Extending_BES_Module" title="Hyrax - Extending BES Module">Extending the BES</a> page.
</p>



</div>
				<!-- end content -->
				<div class="visualClear"></div>
	</div>
</div></div>
</body></html>