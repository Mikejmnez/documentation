
<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<title>UserGuideDataModel - OPeNDAP Documentation</title>
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-UserGuideDataModel skin-monobook action-view">
<div id="globalWrapper">
<div id="column-content"><div id="content" class="mw-body-primary" role="main">
	
	
	<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">UserGuideDataModel</span></h1>
	<div id="bodyContent" class="mw-body">
		<div id="siteSub">From OPeNDAP Documentation</div>
		<div id="contentSub"></div>
		

		<!-- start content -->
<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p><a href="../index.php/UserGuide" title="UserGuide">Back to User Guide Contents</a>
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Data_and_Data_Models"><span class="tocnumber">1</span> <span class="toctext">Data and Data Models</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Data_Models"><span class="tocnumber">1.1</span> <span class="toctext">Data Models</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="#Data_Models_and_APIs"><span class="tocnumber">1.1.1</span> <span class="toctext">Data Models and APIs</span></a></li>
<li class="toclevel-3 tocsection-4"><a href="#Translating_Data_Models"><span class="tocnumber">1.1.2</span> <span class="toctext">Translating Data Models</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-5"><a href="#Data_Access_Protocol"><span class="tocnumber">1.2</span> <span class="toctext">Data Access Protocol</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Data_representation"><span class="tocnumber">1.3</span> <span class="toctext">Data representation</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="#Base_Types"><span class="tocnumber">1.3.1</span> <span class="toctext">Base Types</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#Constructor_Types"><span class="tocnumber">1.3.2</span> <span class="toctext">Constructor Types</span></a>
<ul>
<li class="toclevel-4 tocsection-9"><a href="#Array"><span class="tocnumber">1.3.2.1</span> <span class="toctext">Array</span></a></li>
<li class="toclevel-4 tocsection-10"><a href="#Structure"><span class="tocnumber">1.3.2.2</span> <span class="toctext">Structure</span></a></li>
<li class="toclevel-4 tocsection-11"><a href="#Sequence"><span class="tocnumber">1.3.2.3</span> <span class="toctext">Sequence</span></a></li>
<li class="toclevel-4 tocsection-12"><a href="#Grid"><span class="tocnumber">1.3.2.4</span> <span class="toctext">Grid</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-13"><a href="#External_Data_Representation"><span class="tocnumber">1.3.3</span> <span class="toctext">External Data Representation</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Data_and_Data_Models"><span class="mw-headline-number">1</span> Data and Data Models</span></h1>
<p>Basic to the operation of OPeNDAP is its data model, and the set of
messages that define the communication between client and server.
This chapter presents the data model, and the next
<a href="../index.php/UserGuideOPeNDAPMessages" title="UserGuideOPeNDAPMessages"> presents the messages</a>.
</p>
<h2><span class="mw-headline" id="Data_Models"><span class="mw-headline-number">1.1</span> Data Models</span></h2>
<p>Any data set is made up of data and a data model. The data model
defines the type and arrangement of data values, and may be thought of
as an abstract representation of the relationship between one data
value and another. Though it may seem paradoxical, it is precisely
this relationship that defines the meaning of some number. Without the
context provided by a data model, a number does not represent
anything. For example, within some data set, it may be apparent that a
number represents the value of temperature at some point in space and
time. Without its neighboring temperature measurements, and without
the latitude, longitude, height (or depth), and time, the same number
means nothing.
</p><p>As the model only defines an abstract set of relationships, two data
sets containing different data may share the same data model. For
example, the data produced by two different measurements with the same
instrument will use the same data model, though the values of the data
are different. Sometimes two models may be equivalent.  For example,
an XBT (eXpendable BathyThermograph) measures a time series of
temperature near the surface of the ocean, but is usually stored as a
series of temperature and depth measurements.  The temperature vs.
time model of the original data is equivalent to the temperature vs.
depth model of the stored data.
</p><p>In a computational sense, a data model may be considered to be the 
data type or collection of data types used to represent that data. A
temperature measurement might occur as half an entry in a sequence of
temperature and depth pairs. However the data model also includes the
scalar latitude, longitude and date that identify the time and place
where the temperature measurements were taken. Thus the data set might
be represented in a C-like syntax like this:
</p>
<pre>
Dataset {
   Float64 lat;
   Float64 lon;
   Int32 minutes;
   Int32 day;
   Int32 year;
   Sequence {
      Float64 depth;
      Float64 temperature;
   } cast;
} xbt-station;

</pre>
<p>Example Data Description of XBT Station
</p><p><br />
The above example describes a data set that contains all the
data from a single XBT.  The data set is called <font color="green">xbt-station</font>, and
contains floating-point representations of the latitude and longitude
of the station, and three integers that specify <em>when</em> the XBT
measurements were made. The <font color="green">xbt-station</font> contains a single sequence (called
<font color="green">cast</font>) of measurements, which are here represented as values for
depth and temperature.
</p><p>A slightly different data model representing the same data might look like
this:
</p>
<pre>
Dataset {
   Structure {
      Float64 lat;
      Float64 lon;
   } location;
   Structure {
      Int32 minutes;
      Int32 day;
      Int32 year;
   } time;
   Sequence {
      Float64 depth;
      Float64 temperature;
   } cast;
} xbt-station;
</pre>
<p>Example Data Description of XBT Station Using Structures
</p><p><br /> 
</p><p>In this example, several of the data have been grouped, implying a
relation between them. The nature of the relationship is not defined,
but it is clear that <font color="green">lat</font> and <font color="green">lon</font> are both components of <font color="green">location</font>, and that each measurement in the <font color="green">cast</font> sequence is made up of depth and temperature values.
</p><p>In these two examples, meaning was added to the data set only by
providing a more refined context for the data values. No other data
was added, but still the second example can be said to contain more
information than the first one.
</p><p>These two examples are refinements of the same basic arrangement of
data. However, there is nothing that says that a completely different
data model can't be just as useful or just as accurate. For example,
the depth and temperature data, instead of being represented by a
sequence of pairs could be represented by a pair of
sequences or arrays:
</p>
<pre>
Dataset {
   Structure {
      Float64 lat;
      Float64 lon;
   } location;
   Structure {
      Int32 minutes;
      Int32 day;
      Int32 year;
   } time;
   Float64 depth[500];
   Float64 temperature[500];
} xbt-station;
</pre>
<p>Example Data Description of XBT Station Using Arrays
</p><p><br /> 
The relationship between the depth and temperature variables
is no longer quite as clear, but, depending on what sort of processing is
intended, this may not be that important a loss.
</p><p>The choice of a computational data model to contain some data set
depends in many cases on the whims and preferences of the user, as
well as on the data analysis software to be used. Several different
data models may be equally useful for a given task. Of course, some
data models will contain more information about the data than others,
but this information can also be carried in a researcher's head.
</p><p>Note that with a carefully chosen set of data type constructors,
such as those we've used in the preceding examples, a user can
implement an infinite number of data models.  The examples above use
the OPeNDAP Dataset Descriptor Structure (DDS) format, which will
become important in later discussions of the details of the OPeNDAP Data
Access Protocol. The precise details of the DDS syntax are described
in <a href="../index.php/UserGuideOPeNDAPMessages#Dataset_Descriptor_Structure" title="UserGuideOPeNDAPMessages"> DDS</a>.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Data_Models_and_APIs"><span class="mw-headline-number">1.1.1</span> Data Models and APIs</span></h3>
<p>A data access Application Program Interface (API) is a library of
functions designed to be used by a computer program to read, write,
and sample data. Any given data access API can be said to define
implicitly some data model.  (Or, at least, it will define
restrictions on the data model you can use.)  That is, the functions
that make up the API accept and return data using a certain collection
of computational data types: multi-dimensional arrays might be
required for some data, scalars for others, sequences for others. This
collection of data types, and their use constitute the data model
represented by that API. (Or data models&#8212;there is no reason an
API cannot accommodate several different models.)
</p><p><br />
</p>
<h3><span class="mw-headline" id="Translating_Data_Models"><span class="mw-headline-number">1.1.2</span> Translating Data Models</span></h3>
<p>The problem of data model translation is central to the implementation
of OPeNDAP. With an effective data translator, an OPeNDAP program originally
designed to read netCDF data can have some access to data sets that
use an incompatible data model, such as JGOFS.
</p><p>In general, it is not possible to define an algorithm that will
translate data from any model to any other, without losing information
defined by the position of data values or the relations between them.
Some of these incompatibilities are obvious; a data model designed for
time series data may not be able to accommodate multi-dimensional
arrays.  Others are more subtle.  For example, a Sequence looks very
similar to a collection of Arrays in many respects.  But this does not
mean they can always be translated from one to the other.  For
example, some APIs only return one Sequence "instance" at a time.
This means that even if a Sequence of sets of three numbers is more or
less the same shape as three parallel Arrays, it will be very
difficult to model the one kind of behavior on the other kind of API.
</p><p>However, even though the general problem isn't solvable, there are
many useful translations that can be done, and there are many others
that are still useful despite their inherent information loss.
</p><p>For example, consider a relational structure like the one below. This
is similar to the examples in <a href="#Data_Models">#Data_Models</a>, but contains two nested Sequences.  The outer Sequence represents
all the XBT drops in a cruise, and the inner Sequence represents each
XBT drop.  The JGOFS API was designed to use this sort of data type.
</p>
<pre>
Dataset {
   Sequence {
      Int32 id;
      Float64 latitude;
      Float64 longitude;
      Sequence {
         Float64 depth;
         Float64 temperature;
      } xbt_drop;
   } station;
} cruise;
</pre>
<p>Example Data Description of XBT Cruise
</p><p><br /> 
Note that each entry in the <font color="green">cruise</font> sequence is composed of a
tuple of data values (one of which is itself a sequence). Were we to
arrange these data values as a table, they might look like this:
</p>
<pre>
id   lat   lon   depth  temp
1   10.8   60.8    0     70
                  10     46
                  20     34
2   11.2   61.0    0     71
                  10     45
                  20     34
3   11.6   61.2    0     69
                  10     47
                  20     34 
</pre>
<p>This can be made into an array, although that introduces redundancy.
</p>
<pre>
id   lat   lon   depth  temp
1   10.8   60.8    0     70
1   10.8   60.8   10     46
1   10.8   60.8   20     34
2   11.2   61.0    0     71
2   11.2   61.0   10     45
2   11.2   61.0   20     34
3   11.6   61.2    0     69
3   11.6   61.2   10     47
3   11.6   61.2   20     34
</pre>
<p>The data is now in a form that may be read by an API such as
netCDF. But consider the analysis stage. Suppose a user wants to see
graphs of each station's data. It is not obvious simply from the arrangement
of the array where a station stops and the next one begins.  Analyzing
data in this format is not a function likely to be accommodated by a
program that uses the netCDF API, even though it is theoretically
possible to implement.
</p>
<h2><span class="mw-headline" id="Data_Access_Protocol"><span class="mw-headline-number">1.2</span> Data Access Protocol</span></h2>
<p>The OPeNDAP Data Access Protocol (DAP) defines how an OPeNDAP client
and an OPeNDAP server communicate with one another to pass data from the
server to the client. The job of the functions in the OPeNDAP client
library is to translate data from the DAP into the form expected by
the data access API for which the OPeNDAP library is substituting. The
job of an OPeNDAP server is to translate data stored on a disk in whatever
format they happen to be stored in to the DAP for transmission to the
client.
</p><p>The DAP consists of several components:
</p><p><br />
</p>
<ol>
<li> An "intermediate data representation" for data sets. This is used to transport data from the remote source to the client. The data types that make up this representation may be thought of as the OPeNDAP data model.
</li>
<li> A format for the "ancillary data" needed to translate a data set into the intermediate representation, and to translate the intermediate representation into the target data model. The ancillary data in turn consists of two pieces:
<ul>
<li> A description of the shape and size of the various data types stored in some given data set. This is called the <font color="green">Data Description Structure (DDS)</font>.
</li>
<li> Capsule descriptions of some of the properties of the data stored in some given data set.  This is the <font color="green">Data Attribute Structure (DAS)</font>.
</li>
</ul>
</li>
<li> A "procedure" for retrieving data and ancillary data from remote platforms.
</li>
<li> An "API" consisting of OPeNDAP classes and data access calls designed to implement the protocol,
</li>
</ol>
<p>The intermediate data representation and the ancillary data formats
are introduced in <a href="../index.php/UserGuideOPeNDAPMessages" title="UserGuideOPeNDAPMessages">OPeNDAP Messages</a>, as
are the steps of the procedure.  The actual details of the software
used to implement these formats and procedures is a subject of the
documentation of the respective software.
</p>
<h2><span class="mw-headline" id="Data_representation"><span class="mw-headline-number">1.3</span> Data representation</span></h2>
<p>There are many popular data storage formats, and many more than that in
use.  These formats are optimized (it they are optimized at all) for data
storage, and are not generally suitable for data transmission.  In order to
transmit data over the Internet, OPeNDAP must translate the data model used
by a particular storage format into the data model used for transmission.
</p><p>If the data model for transmission is defined to be general enough to
encompass the abstractions of several data models for storage, than
this intermediate representation&#8212;the transmission
format&#8212;can be used to translate between one data model and
another.
</p><p>The OPeNDAP data model consists of a fairly elementary set of base types, combined
with an advanced set of constructs and operators that allows it to
define data types of arbitrary complexity.  This way, the OPeNDAP data access
protocol can be used to transmit data from virtually any data storage format.
</p><p>The elements of the OPeNDAP data access protocol are:
</p><p><br />
</p>
<dl>
<dt>Base Types 
</dt>
<dd>These are the simple data types, like integers, floating point numbers, strings, and character data.
</dd>
<dt>Constructor 
</dt>
<dd>Types These are the more complex data types that can be constructed from the simple base types.  Examples are structures, sequences, arrays, and grids.
</dd>
<dt>Operators
</dt>
<dd>Access to data can be operationally defined with operators defined on the various data types.
</dd>
<dt> External Data Representation
</dt>
<dd>In order to transmit the data across the Internet, there needs to be a machine-independent definition of what the various data types look like.  For example, the client and server need to agree on the most significant digit of a particular byte in the message
</dd>
</dl>
<p>These elements are defined in greater detail in the sections that follow.
</p>
<h3><span class="mw-headline" id="Base_Types"><span class="mw-headline-number">1.3.1</span> Base Types</span></h3>
<p>The OPeNDAP data model uses the concepts of variables and operators. Each
data set is defined by a set of one or more variables, and each
variable is defined by a set of attributes. A variable's
<i>attributes</i>&#8212;such as units, name and type&#8212;must not be
confused with the data <i>value</i> (or values) that may be
represented by that variable. A variable called <font color="green">time</font> may contain
an integer number of minutes, but it does not contain a particular
number of minutes until a context, such as a specific event recorded
in a data set, is provided. Each variable may further be the object of
an operator that defines a subset of the available data set.
</p><p>Variables in the DAP have two forms. They are either base types
or type constructors.  Base type variables are similar to predefined
variables in procedural programming languages like C or Fortran (such
as <font color="green">int</font> or <font color="green">integer*4</font>).  While these certainly have an internal structure, it is not possible to access parts of that structure using the DAP. Base type variables in the DAP have two
predefined attributes (or characteristics): name, and type.
They are defined as follows:
</p><p><br />
</p>
<blockquote>
<dl>
<dt>Name 
</dt>
<dd>A unique identifier that can be used to reference the part of the dataset associated with this variable.
</dd>
</dl>
<p><br />
</p>
<dl>
<dt>Type
</dt>
<dd>The data type contained by the variable. This can be one of <font color="green">Byte</font>, <font color="green">Int32</font>, <font color="green">UInt32</font>, <font color="green">Float64</font>, <font color="green">String</font>, and <font color="green">URL</font>.  Where:
</dd>
</dl>
<blockquote>
<ul>
<li><font color="green">Byte</font> is a single byte of data. This is the same as <font color="green">unsigned char</font> in ANSI C.
</li>
<li><font color="green">Int16</font> is a 16 bit two's complement integer&#8212;it is synonymous with long in ANSI C when that type is implemented as 16 bits.
</li>
<li><font color="green">UInt16</font> is a 16 bit unsigned integer.
</li>
<li><font color="green">Int32</font> is a 32 bit two's complement integer&#8212;it is synonymous with long in ANSI C when that type is implemented as 32 bits.
</li>
<li><font color="green">UInt32</font> is a 32 bit unsigned integer.
</li>
<li><font color="green">Float32</font> is the IEEE 32 bit floating point data type.
</li>
<li><font color="green">Float64</font> is the IEEE 64 bit floating point data type.
</li>
<li><font color="green">String</font> is a sequence of bytes terminated by a null character.
</li>
<li><font color="green">Url</font> is a string containing an OPeNDAP URL. </blockquote>
</li>
</ul>
</blockquote>
<p>The declaration in a <a href="../index.php/UserGuideOPeNDAPMessages#Data_Descriptor_Structure" title="UserGuideOPeNDAPMessages">DDS</a> of a variable of any of the base types is simply the type of the variable,
followed by its name, and a semicolon.  For example, to declare a
<font color="green">month</font> variable to be a 32-bit integer, one
would type:
</p>
<pre>
Int32 month;
</pre>
<h3><span class="mw-headline" id="Constructor_Types"><span class="mw-headline-number">1.3.2</span> Constructor Types</span></h3>
<p>Constructor types, such as arrays and structures, describe the
grouping of one or more variables within a dataset. These classes are
used to describe different types of relations between the variables
that comprise the dataset. For example, an array might indicate that
the variables grouped are all measurements of the same quantity with
some spatial relation to one another, whereas a structure might
indicate a grouping of measurements of disparate quantities that
happened at the same place and time.
</p><p>There are six classes of type constructor variables defined by the
OPeNDAP DAP: arrays, structures, sequences, functions, and grids.
The types are defined as:
</p>
<h4><span class="mw-headline" id="Array"><span class="mw-headline-number">1.3.2.1</span> Array</span></h4>
<p>An array is a one dimensional indexed data structure as defined by
ANSI C. Multidimensional arrays are defined as arrays of arrays. An
array may be subsampled using subscripts or ranges of subscripts
enclosed in brackets (<font color="green">[]</font>).  For example,
<font color="green">temp[3][4]</font> would indicate the value in the
fourth row and fifth column of the <font color="green">temp</font>
array. (As in C, OPeNDAP array indices start at zero.)
</p><p>A chunk of an array may be specified with subscript ranges; the array
<font color="green">temp[2:10][3:4]</font> indicates an array of nine
rows and two columns whose values have been lifted intact from the
larger <font color="green">temp</font> array.
</p><p><br />
A <i>hyperslab</i> may be selected from an array with a <i>stride</i>
value. The array represented by <font color="green">temp[2:2:10][3:4]</font> would have only five rows; the
middle value in the first subscript range indicates that the output
array values are to be selected from alternate input array rows. The
array <font color="green">temp[2:3:10][3:4]</font> would select from
every third row, and so on. 
</p><p>A <a href="../index.php/UserGuideOPeNDAPMessages#Data_Descriptor_Structure" title="UserGuideOPeNDAPMessages">DDS</a> declaration of a
<font color="green">5x6</font> array of floating point numbers
would look like this:
</p>
<pre>
Float64 data[5][6];
</pre>
<p>In addition to its magnitude, every dimension of an array may also
have a name.  The previous declaration could be written:
</p>
<pre>
Float64 data[height = 5][width = 6];
</pre>
<h4><span class="mw-headline" id="Structure"><span class="mw-headline-number">1.3.2.2</span> Structure</span></h4>
<p>A Structure is a class that may contain
several variables of different classes. However, though it implies
that its member variables are related somehow, it conveys no
relational information about them. The structure type can also be
used to group a set of unrelated variables together into a single
dataset. The "dataset" class name is a synonym for structure.
</p><p>A <a href="../index.php/UserGuideOPeNDAPMessages#Data_Descriptor_Structure" title="UserGuideOPeNDAPMessages">DDS</a> Structure declaration
containing some data and the month in which the data was taken might
look like this:
</p>
<pre>
   Structure {
      Int32 month;
      Float64 data[5][6];
   } measurement;
</pre>
<p>Use the <b>.</b> operator to refer to members of a Structure.  For
example, <font color="green">measurement.month</font> would identify
the integer member of the Structure defined in the above
declaration.
</p><p><br />
</p>
<h4><span class="mw-headline" id="Sequence"><span class="mw-headline-number">1.3.2.3</span> Sequence</span></h4>
<p>A Sequence is an ordered set of variables each of which may have
several values. The variables may be of different classes.  Each
element of a Sequence consists of a value for each member variable, so
a Sequence is sort of like an ordered set of Structures.
</p><p>Thus a Sequence can be
represented as:
</p>
<center>
<table border="0">

<tr>
<td> s<sub>00</sub> </td>
<td> s<sub>01</sub> </td>
<td> ... </td>
<td> s<sub>0n</sub>
</td></tr>
<tr>
<td> s<sub>10</sub> </td>
<td> s<sub>11</sub> </td>
<td> ... </td>
<td> s<sub>1n</sub>
</td></tr>
<tr>
<td> s<sub>20</sub> </td>
<td> s<sub>21</sub> </td>
<td> ... </td>
<td> s<sub>2n</sub>
</td></tr>
<tr>
<td> . </td>
<td> ... </td>
<td> ... </td>
<td> .
</td></tr>
<tr>
<td> . </td>
<td> ... </td>
<td> ... </td>
<td> .
</td></tr>
<tr>
<td> . </td>
<td> ... </td>
<td> ... </td>
<td> .
</td></tr>
<tr>
<td> s<sub>i0</sub>  </td>
<td> s<sub>i1</sub> </td>
<td> ... </td>
<td> s<sub>in</sub>
</td></tr></table>
</center>
<p><br /> 
Every instance of Sequence <font color="green">S</font> has the same
number, order, and class of its member variables. A Sequence implies
that each of the variables is related to each other in some logical
way. For example, a Sequence containing <font color="green">position</font> and
<font color="green">temperature</font> measurements might imply that each
<font color="green">temperature</font> measurement was taken at the corresponding
<font color="green">position</font>. A Sequence is different from a Structure because its
constituent variables have several instances while a Structure's
variables have only one instance (or value).
</p><p>A Sequence declaration is similar to a Structure's.
For example, the following would define a Sequence that would
contain many members like the Structure defined above:
</p>
<pre>
   Sequence {
      Int32 month;
      Float64 data[5][6];
   } measurement;
</pre>
<p>Note that, unlike an Array, a Sequence has no index.  This means that
a Sequence's values are not simultaneously accessible.  Instead, a
Sequence has an implied <i>state</i>, corresponding to a single element in
the Sequence.  
</p><p>As with a Structure, the variable <font color="green">measurement.month</font> has a single value.  The
distinction is that this variable's value changes depending on the
state of the Sequence.  You can think of a Sequence as composed of the
data you get from successive reads of data from a file.  The data
values available at any point are the last values read from the file.
But you don't have immediate access to any of the other values in that
file.
</p>
<h4><span class="mw-headline" id="Grid"><span class="mw-headline-number">1.3.2.4</span> Grid</span></h4>
<p>A Grid is an association of an <font color="green">N</font>
dimensional array with <font color="green">N</font> named vectors
(one-dimensional arrays), each of which has the same number of
elements as the corresponding dimension of the array.  Each data value
in the Grid is associated with the data values in the vectors
associated with its dimensions.
</p><p>As an example, consider an array of temperature values that has six
columns and five rows. Suppose that this array represents
measurements of temperature at five different depths in six
different locations. The problem is the indication of the precise
location of each temperature measurement, relative to one
another.
</p><p>If the six locations are evenly spaced, and the five depths are also
evenly spaced, then the data set can be completely described using
the array and two scalar values indicating the distance between
adjacent vertices of the array. However, if the spacing of the
measurements is <i>not</i>  regular, as in <a href="../index.php/File:Grid.gif" title="File:Grid.gif">figure 6.3.2</a>
then an array will be inadequate.  To adequately describe the
positions of each of the points in the grid, the precise location of
each column and row must be described.
</p>
<center>
<p><a href="../index.php/File:Grid.gif" class="image" title="actual size"><img alt="actual size" src="../images/6/64/Grid.gif" width="282" height="277" /></a> 
</p><p>An Irregular Grid of Data.
</p>
</center>
<p><br /> 
The secondary vectors in the Grid data type provide a solution to this
problem. Each member of these vectors associates a value for all the
data points in the corresponding rank of the array.  The value can
represent location or time or some other quantity, and can even be a
constructor data type.  The following declaration would define a data
type that could accommodate a structure like this:
</p>
<pre>
 Grid {
      Float64 data[distance = 6][depth = 5];
      Float64 distance[6];
      Float64 depth[5];
   } measurement;
 </pre>
<p>In the above example, an vector called <font color="green">depth</font> contains five values corresponding to
the depths of each row of the array, while another vector called <font color="green">distance</font>  contains the scalar distance
between the location of the corresponding column, and some reference
point. 
</p><p>In a similar arrangement, a <font color="green">location</font> array
could instead contain six (latitude, longitude) pairs indicating the
absolute location of each column of the grid.
</p>
<pre>
    Grid {
      Float64 data[distance = 6][depth = 5];
      Float64 depth[5];
      Array Structure {
         Float64 latitude;
         Float64 longitude;
      } location[6];
   } measurement;
</pre>
<h3><span class="mw-headline" id="External_Data_Representation"><span class="mw-headline-number">1.3.3</span> External Data Representation</span></h3>
<p>Now that you know what the data types are, the next step is to define
their external representation.  The DAP defines an external
representation for each of the base-type and constructor-type
variables. This is used when an object of the given type is
transferred from one computer to another.  Defining a single external
representation makes possible the translation of variables from one
computer to another when those computers use different internal
representations for those variable types.
</p><p>The data access protocol uses Sun Microsystems' XDR protocol for the
external representation of all of the base type variables.  The table
below shows the XDR types used to represent the various base type
variables.
</p><p><br />
</p>
<center>
<p>The XDR data types corresponding to OPeNDAP base-type variables.
</p>
<table border="3">
<tr>
<th> Base Type </th>
<th> XDR Type
</th></tr>
<tr>
<td> Byte  </td>
<td> xdr byte
</td></tr>
<tr>
<td> Int16  </td>
<td> xdr int16
</td></tr>
<tr>
<td> UInt16 </td>
<td> xdr unsigned int16
</td></tr>
<tr>
<td> Int32  </td>
<td> xdr int32
</td></tr>
<tr>
<td> UInt32 </td>
<td> xdr unsigned int32
</td></tr>
<tr>
<td> Float32 </td>
<td>xdr float
</td></tr>
<tr>
<td> Float64 </td>
<td>xdr double
</td></tr>
<tr>
<td> String </td>
<td> xdr string
</td></tr>
<tr>
<td> URL </td>
<td> xdr string
</td></tr></table>
</center>
<p>A base type variable is always either transmitted or not.  You won't
ever see a fraction of an String type transmitted.  The constructor
type variables, being made up of the bast type variables, are
transmitted as sets of base type variables, and these may be sampled,
with a <a href="../index.php/UserGuideOPeNDAPMessages#Constraint_Expression" title="UserGuideOPeNDAPMessages"> constraint
expression</a>.
</p><p>Constraint expressions do not affect <i>how</i>  a base-type variable
is transmitted from a client to a server; they determine <i>if</i>  a
variable is to be transmitted.  For constructor type variables,
however, constraint expressions may be used to exclude portions of the
variable. For example, if a constraint expression is used to select
the first three of six fields in a structure, the last three fields of
that structure are not transmitted by the server.
</p><p>What remains is to define the external representation of the
constructor type variables.  For each of the six constructor types
these definitions are:
</p>
<dl>
<dt>Array 
</dt>
<dd>An Array is sent using the <font color="green">xdr_array</font> function. This means that an Array of 100 <font color="green">Int32</font>s is sent as a single block of 100 <font color="green">xdr long</font>s, not 100 separate "xdr long"s.
</dd>
<dt>Structure
</dt>
<dd>A Structure is sent by encoding each field in the order those fields are declared in the <a href="../index.php/UserGuideOPeNDAPMessages#Data_Descriptor_Structure" title="UserGuideOPeNDAPMessages">DDS</a> and transmitting the resulting block of bytes.
</dd>
<dt>Sequence
</dt>
<dd>A Sequence is transmitted by encoding each item in the sequence as if it were a Structure, and ending each such structure after the other, in the order of their occurrence in the sequence. The entire sequence is sent, subject to the constraint expression. In other words, if no constraint expression is supplied then the entire sequence is sent. However, if a constraint expression is given all the records in the sequence that satisfy the expression are sent.
</dd>
<dt>Grid 
</dt>
<dd>A Grid is encoded as if it were a Structure (one component after the other, in the order of their declaration).
</dd>
</dl>
<p>The external data representation used by an OPeNDAP server and client
may be compressed, depending on the configuration of the respective
machines.  The compression is done using the <font color="green">gzip</font> 
program.  Only the data transmission itself
will be affected by this; the transmission of the ancillary data is
not compressed.
</p>



</div>
				<!-- end content -->
				<div class="visualClear"></div>
	</div>
</div></div>
</body></html>