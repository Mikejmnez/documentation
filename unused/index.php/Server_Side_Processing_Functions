
<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<title>Server Side Processing Functions - OPeNDAP Documentation</title>
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Server_Side_Processing_Functions skin-monobook action-view">
<div id="globalWrapper">
<div id="column-content"><div id="content" class="mw-body-primary" role="main">
	
	
	<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Server Side Processing Functions</span></h1>
	<div id="bodyContent" class="mw-body">
		<div id="siteSub">From OPeNDAP Documentation</div>
		<div id="contentSub"></div>
		

		<!-- start content -->
<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Server_functions.2C_invocation_and_composition"><span class="tocnumber">1</span> <span class="toctext">Server functions, invocation and composition</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Calling_Syntax"><span class="tocnumber">1.1</span> <span class="toctext">Calling Syntax</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Function_Composition"><span class="tocnumber">1.2</span> <span class="toctext">Function Composition</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Server_Functions_in_the_BES_functions_Module"><span class="tocnumber">2</span> <span class="toctext">Server Functions in the <i>BES functions</i> Module</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#geogrid.28.29"><span class="tocnumber">2.1</span> <span class="toctext">geogrid()</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#grid.28.29"><span class="tocnumber">2.2</span> <span class="toctext">grid()</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#linear_scale"><span class="tocnumber">2.3</span> <span class="toctext">linear_scale</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#The_make_array.28.29_function"><span class="tocnumber">2.4</span> <span class="toctext">The make_array() function</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#The_.27make_array.27_special_forms"><span class="tocnumber">2.5</span> <span class="toctext">The 'make array' special forms</span></a>
<ul>
<li class="toclevel-3 tocsection-10"><a href="#Performance_measurements"><span class="tocnumber">2.5.1</span> <span class="toctext">Performance measurements</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#Raw_timing_data"><span class="tocnumber">2.5.2</span> <span class="toctext">Raw timing data</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="#bind_name.28.29_and_bind_shape.28.29"><span class="tocnumber">2.6</span> <span class="toctext">bind_name() and bind_shape()</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Unstructured_Grid_subsetting"><span class="tocnumber">2.7</span> <span class="toctext">Unstructured Grid subsetting</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#version.28.29"><span class="tocnumber">2.8</span> <span class="toctext">version()</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#tabular.28.29"><span class="tocnumber">2.9</span> <span class="toctext">tabular()</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#roi.28.29"><span class="tocnumber">2.10</span> <span class="toctext">roi()</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#bbox.28.29"><span class="tocnumber">2.11</span> <span class="toctext">bbox()</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#bbox_union.28.29"><span class="tocnumber">2.12</span> <span class="toctext">bbox_union()</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="#Functions_Included_FreeForm_Module"><span class="tocnumber">3</span> <span class="toctext">Functions Included <i>FreeForm Module</i></span></a>
<ul>
<li class="toclevel-2 tocsection-20"><a href="#Projection_functions"><span class="tocnumber">3.1</span> <span class="toctext">Projection functions</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Selection_functions"><span class="tocnumber">3.2</span> <span class="toctext">Selection functions</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Server_functions.2C_invocation_and_composition"><span class="mw-headline-number">1</span> Server functions, invocation and composition</span></h2>
<h5><span class="mw-headline" id="Calling_Syntax"><span class="mw-headline-number">1.1</span> Calling Syntax</span></h5>
<p>To run a server function, you call the function with its arguments in the 'query string' part of a URL. The server function call is a kind of DAP Constraint Expression. Here are some examples:
</p>
<dl>
<dt>Get the U and V components of the fnoc1 dataset, but apply the dataset's scale_factor attribute (the 'm' in y=mx+b; for these variables, 'b' is zero). Compare the values returned by the linear_scale() server function to those returned by accessing the variables without using the function
</dt>
<dd><a rel="nofollow" class="external free" href="http://test.opendap.org/dap/data/nc/fnoc1.nc.ascii?linear_scale(u),linear_scale(v)">http://test.opendap.org/dap/data/nc/fnoc1.nc.ascii?linear_scale(u),linear_scale(v)</a>
</dd>
<dd><a rel="nofollow" class="external free" href="http://test.opendap.org/dap/data/nc/fnoc1.nc.ascii?u,v">http://test.opendap.org/dap/data/nc/fnoc1.nc.ascii?u,v</a>
</dd>
</dl>
<h5><span class="mw-headline" id="Function_Composition"><span class="mw-headline-number">1.2</span> Function Composition</span></h5>
<p>Server-side functions provide a way to access the processing power of the data server and perform operations that fall outside the scope of the DAP constraint mechanism of projection and selection. Each server can load functions at run-time, so the set of functions supported may be different than those documented here. Use the <i>version()</i> function to get a list of functions supported by a particular server. To get information about a particular function, call that function with no arguments. The 'help' response from both <i>version()</i> and a function such as <i>linear_scale()</i> is a simple XML document listing the function's name, version and URL to more complete documentation.
</p><p>All the functions here are included in the Hyrax server, version 1.6 and later. Other servers may also support these.
</p><p>All of these functions can be composed. Thus, the values from the geogrid() function can be used by the linear_scale() function. Here's an example:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"> linear_scale<span class="br0">&#40;</span>geogrid<span class="br0">&#40;</span>SST<span class="sy0">,</span> <span class="nu0">45</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">82</span><span class="sy0">,</span> <span class="nu0">40</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">78</span><span class="br0">&#41;</span><span class="br0">&#41;</span>  <span class="co1">// spaces added for clarity; in reality spaces in server function arg lists are a syntax error</span></pre></div></div>
<p>This first subsets the variable <i>SST</i> so only those values in latitude 45 to 40 and longitude -82 to -78 are returned and then passes those values to the linear_scale() function, which will scale them and return those new values to the caller.
</p>
<h2><span class="mw-headline" id="Server_Functions_in_the_BES_functions_Module"><span class="mw-headline-number">2</span> Server Functions in the <i>BES functions</i> Module</span></h2>
<p>For Hyrax 1.9, the server functions listed here were moved from libdap, where they were 'hard coded' into the constraint evaluator, to a module that is loaded like the other BES modules. Currently this 'functions' module is part of the BES source code while we decide where it should reside. Also note that <i>make_array()</i>, the <i>#Type</i> special form, <i>bind_name()</i> and <i>bind_shape()</i> are new functions designed to pass large arrays filled with constant values into custom server functions. We will expand on these as part of an NSF-sponsored project in the coming two years.
</p>
<h3><span class="mw-headline" id="geogrid.28.29"><span class="mw-headline-number">2.1</span> geogrid()</span></h3>
<p>Version documented: 1.2
</p><p>The geogrid() function applies a constraint given in latitude and longitude to a DAP Grid variable. The arguments to the function are:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">geogrid<span class="br0">&#40;</span>grid variable<span class="sy0">,</span> top<span class="sy0">,</span> left<span class="sy0">,</span> bottom<span class="sy0">,</span> right<span class="br0">&#91;</span><span class="sy0">,</span> expression ...<span class="br0">&#93;</span><span class="br0">&#41;</span>
geogrid<span class="br0">&#40;</span>grid variable<span class="sy0">,</span> latitude map<span class="sy0">,</span> longitude map<span class="sy0">,</span> top<span class="sy0">,</span> left<span class="sy0">,</span> bottom<span class="sy0">,</span> right<span class="br0">&#91;</span><span class="sy0">,</span> expression ...<span class="br0">&#93;</span><span class="br0">&#41;</span></pre></div></div>
<p>The <i>grid variable</i> is the data to be sub-sampled and must be a Grid. The optional latitude and longitude maps must be Maps in the named Grid and specifying these overrides the <i>geogrid</i> heuristics for choosing the lat/lon maps. The Top, left, bottom, right are the latitude and longitude coordinates of the northwesterm and southeastern corners of the selection box. The expressions consist of one or more quoted relational expressions.  See grid() for more information about the expressions.
</p><p>The function will always return a single Grid variable whose values completely cover the given region, although there may be cases when some additional data are also returned. If the longitude values 'wrap around' the right edge of the data, then the function will make two requests and return those joined together as a single Grid. If the data are stored with the southern latitudes at the top of the array, the return result will be flipped so that the northern latitudes are at the top. If the Longitude values are offset, the function will correct for that, as well.
</p>
<hr />
<p>Version documented: 1.1
</p><p>The geogrid() function applies a constraint given in latitude and longitude to a DAP Grid variable. The arguments to the function are:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"> geogrid<span class="br0">&#40;</span>variable<span class="sy0">,</span> top<span class="sy0">,</span> left<span class="sy0">,</span> bottom<span class="sy0">,</span> right<span class="br0">&#91;</span><span class="sy0">,</span> expression ...<span class="br0">&#93;</span><span class="br0">&#41;</span></pre></div></div>
<p>The <i>variable</i> is the data to be sub-sampled. The Top, left, bottom, right are the latitude and longitude coordinates of the northwesterm and southeastern corners of the selection box. The expressions consist of one or more quoted relational expressions.  See grid() for more information about the expressions.
</p><p>The function will always return a single Grid variable whose values completely cover the given region, although there may be cases when some additional data are also returned. If the longitude values 'wrap around' the right edge of the data, then the function will make two requests and return those joined together as a single Grid. If the data are stored with the southern latitudes at the top of the array, the return result will be flipped so that the northern latitudes are at the top.
</p>
<h3><span class="mw-headline" id="grid.28.29"><span class="mw-headline-number">2.2</span> grid()</span></h3>
<p>Version documented: 1.0
</p><p>The grid() function takes a DAP Grid variable and zero or more relational expressions. Each relational expression is applied to the grid using the server's constraint evaluator and the resulting grid is returned. The expressions may use constants and the grid's map vectors but may not use any other variables. In particular, you cannot use the grid values themselves
</p><p>Two forms of expression are provided:
</p>
<ol>
<li> "var relop const"
</li>
<li> "const relop var relop const"
</li>
</ol>
<p>Where <i>relop</i> stands for one of the relational operators, like <tt>=</tt> and <tt> &gt; </tt>
</p><p>For example: grid(sst,"20&gt;TIME&gt;=10") and grid(sst,"20&gt;TIME","TIME&gt;=10") are both legal and, in this case, also equivalent.
</p>
<h3><span class="mw-headline" id="linear_scale"><span class="mw-headline-number">2.3</span> linear_scale</span></h3>
<p>Version documented: 1.0b1
</p><p>The linear_scale() function applies the familiar y = mx + b equation to data. It has three forms:
</p>
<ol>
<li> linear_scale(var)
</li>
<li> linear_scale(var,scale_factor,add_offset)
</li>
<li> linear_scale(var,scale_factor,add_offset,missing_value)
</li>
</ol>
<p>If only the name of a variable is given, the function looks for the COARDS/CF-1.0 <i>scale_factor</i>, <i>add_offset</i> and <i>missing_value</i> attributes. In the equation, 'm' is scale_factor, 'b' is add_offset and data values that match missing_value are not scaled.
</p><p>If add_offset cannot be found, it defaults to zero; if missing_value cannot be found, the test for it is not performed.
</p><p>In the second and third form, if the given values conflict with the dataset's attributes, the given values override.
</p>
<h3><span class="mw-headline" id="The_make_array.28.29_function"><span class="mw-headline-number">2.4</span> The make_array() function</span></h3>
<p>The <i>make_array()</i> function takes three or more arguments and returns a DAP2 Array with the values passed to the function.
</p>
<dl>
<dt>make_array(&lt;<i>type</i>&gt;, &lt;<i>shape</i>&gt;, &lt;<i>values</i>&gt;, ...)</dt>
<dd> &lt;<i>type</i>&gt; is any of the DAP2 numeric types (Byte, Int16, UInt16, Int32, UInt32, Float32, Float64); &lt;<i>shape</i>&gt; is a string that indicates the size and number of the array's dimensions. Following those two arguments are N arguments that are the values of the array. The number of values must equal the product of the dimension sizes.
</dd>
</dl>
<p>Example: make_array(Byte,"[4][4]",2,3,4,5,2,3,4,5,2,3,4,5,2,3,4,5) will return a DAP2 four by four Array of Bytes with the values 2, 3, ... . The Array will be named <i>g&lt;int&gt;</i> where &lt;int&gt; is 1, 2, ..., such that the name does not conflict with any existing variable in the dataset. Use <i>bind_name()</i> to change the name.
</p><p>This function can build an array with 1024 X 1024 Int32 elements in about 4 seconds.
</p>
<h3><span class="mw-headline" id="The_.27make_array.27_special_forms"><span class="mw-headline-number">2.5</span> The 'make array' special forms</span></h3>
<p>These special forms can build vectors with specific values and return them as DAP2 Arrays. The Array variables can be named using the <i>bind_name()</i> function and have their shape set using <i>bind_shape()</i>.
</p>
<dl>
<dt>$&lt;type&gt;(<i>size hint</i>,: <i>values</i>, ...)</dt>
<dd> The <i>$&lt;type&gt;</i> (<i>$Byte</i>, <i>$Int32</i>, ...) literal starts the special form. The first argument <i>size hint</i> provides a way to preallocate the memory needed to hold the vector of values. Following that, the values are listed. Unlike <i>make_array()</i>, it is not necessary to provide the exact size of the vector; the size hint is just that, a hint. If a size hint of zero is supplied, it will be ignored. Any of the DAP2 numeric types can be used with this special form. This is called a 'special form' because it invokes a custom parser that can process values very efficiently.
</dd>
</dl>
<p>Example: $Byte(16:2,3,4,5,2,3,4,5,2,3,4,5,2,3,4,5) will return a one dimensional (i.e., a vector) Array of Bytes with values 2, 3, ... . The vector is named <i>g&lt;int&gt;</i> just like the array returned by make_array(). The vector can be turned in to a N-dimensional Array using <i>bind_shape()</i> using <i>bind_shape("[4][4]",$Byte(16:2,3,4,5,2,3,4,5,2,3,4,5,2,3,4,5)).</i>
</p><p>The special forms can make a 1,047,572 element vector on Int32 in 0.4 seconds, including the time required to parse the million plus values.
</p>
<h4><span class="mw-headline" id="Performance_measurements"><span class="mw-headline-number">2.5.1</span> Performance measurements</span></h4>
<p>Time to make 1,000,000 (actually 1,048,576) element Int32 array using the special form, where the argument vector&lt;int&gt;
was preset to 1,048,576 elements. Times are for 50 repeats.
</p><p>Summary: Using the special for $Int32(size_hint, values...) is about 10 times faster for a 1 million element vector
than make_array(Int32,[1048576],values...). As part of the performance testing, the scanner and parser were run under a sampling runtime analyzer ('Instruments' on OS/X) and the code was optimized so that long sequences of numbers would scan and parse more efficiently. This benefited both the make_array() function and $type() special form.
</p>
<h4><span class="mw-headline" id="Raw_timing_data"><span class="mw-headline-number">2.5.2</span> Raw timing data</span></h4>
<p>In all cases, a 1,048,576 element vector of Int32 was built 50 times. The values were serialized and written to /dev/null using the command <i> time besstandalone -c bes.conf -i bescmd/fast_array_test_3.dods.bescmd -r 50 &gt; /dev/null</i> where the <i>.bescmd</i> file lists a massive constraint expression (a million values). The same values were used.
</p><p>NB: The DAP2 consraint expression scanner was improved based on info from 'instruments', an OS/X profiling tool. Copying values and applying www2id escaping was
moved from the scanner, where it was applied it to every token that matched SCAN_WORD, to the parser, where it
was used only for non-numeric tokens. This performance tweak makes a big difference in this case since there
are a million SCAN_WORD tokens that are not symbols.
</p>
<table class="wikitable">
<caption> Runtimes for make_array() and $type, scanner/parser optimized, two trials
</caption>
<tr>
<th>                           </th>
<th colspan="3"> Time in seconds
</th></tr>
<tr>
<th> What                  </th>
<th> Real (s)  </th>
<th> User     </th>
<th> System
</th></tr>
<tr>
<td> $type, with hint </td>
<td> 19.844 </td>
<td> 19.355 </td>
<td> 0.437
</td></tr>
<tr>
<td> $type, with hint </td>
<td> 19.817 </td>
<td> 19.369 </td>
<td> 0.427
</td></tr>
<tr>
<td>  $type, no hint  </td>
<td> 19.912 </td>
<td> 19.444 </td>
<td> 0.430
</td></tr>
<tr>
<td>  $type, no hint  </td>
<td> 19.988 </td>
<td> 19.444 </td>
<td> 0.428
</td></tr>
<tr>
<td> make_array()     </td>
<td> 195.332 </td>
<td> 189.271 </td>
<td> 6.058
</td></tr>
<tr>
<td> make_array()     </td>
<td> 197.900 </td>
<td> 191.628 </td>
<td> 6.254
</td></tr></table>
<h3><span class="mw-headline" id="bind_name.28.29_and_bind_shape.28.29"><span class="mw-headline-number">2.6</span> bind_name() and bind_shape()</span></h3>
<p>These functions take a BaseType* object and bind a name or shape to it (in the latter case the BaseType* must be an Array*). They are intended to be used with <i>make_array()</i> and the <i>$type</i> special forms, but they can be used with any variable in a dataset.
</p>
<dl>
<dt>bind_name(<i>name</i>,<i>variable</i>)</dt>
<dd> The <i>name</i> must not exist in the dataset; <i>variable</i> may be the name of a variable in the dataset (so this function can rename an existing variable) or it can be a variable returned by another function or special form.
</dd>
<dt>bind_shape(<i>shape expression</i>,<i>variable</i>)</dt>
<dd> The <i>shape expression</i> is a string that gives the number and size of the array's dimensions; the <i>variable</i> may be the name of a variable in the dataset (so this function can rename an existing variable) or it can be a variable returned by another function or special form.
</dd>
</dl>
<p>Here's an example showing how to combine <i>bind_name</i>, <i>bind_shape</i> and <i>$Byte</i> to build an array of constants: <i>bind_shape("[4][4]",bind_name("bob",$Byte(0:2,3,4,5,2,3,4,5,2,3,4,5,2,3,4,5)))</i>. The result, in a browser, is:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="bash source-bash"><pre class="de1">Dataset: function_result_coads_climatology.nc
bob<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span>, <span class="nu0">5</span>
bob<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span>, <span class="nu0">5</span>
bob<span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span>, <span class="nu0">5</span>
bob<span class="br0">&#91;</span><span class="nu0">3</span><span class="br0">&#93;</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span>, <span class="nu0">5</span></pre></div></div>
<h3><span class="mw-headline" id="Unstructured_Grid_subsetting"><span class="mw-headline-number">2.7</span> Unstructured Grid subsetting</span></h3>
<p>The <b>ugr5()</b> function subsets an Unstructured Grid (aka flexible mesh) if it conforms to the <a rel="nofollow" class="external text" href="https://github.com/ugrid-conventions/ugrid-conventions/blob/master/ugrid-conventions.md">Ugrid Conventions</a> built around netCDf and CF. More information on subsetting files that conform to this convention can be found <a rel="nofollow" class="external text" href="https://github.com/ugrid-conventions/ugrid-conventions/blob/master/ugrid-subsetting.md">here</a>.
</p><p>See <a href="../index.php/OPULS:_UGrid_Subsetting" title="OPULS: UGrid Subsetting"> ugr5 documentation</a> for more information.
</p><p>This function is optional with Hyrax and is provided by the ugrid_functions module.
</p>
<h3><span class="mw-headline" id="version.28.29"><span class="mw-headline-number">2.8</span> version()</span></h3>
<p>The <i>version</i> function provides a list of the server-side processing functions available on a given server along with their versions. For information on a specific function, call it with no arguments or look at this page.
</p>
<h3><span class="mw-headline" id="tabular.28.29"><span class="mw-headline-number">2.9</span> tabular()</span></h3>
<p>Brief: Transform one or more arrays to a sequence.
</p><p>This function will transform one or more arrays into a sequence,
where each array becomes a column in the sequence, with one
exception. If each array has the same shape, then the number of
columns in the resulting table is the same as the number of arrays.
If one or more arrays has more dimensions than the others, an
extra column is added for each of those extra dimensions. Arrays
are enumerated in row-major order (the right-most dimension varies
fastest).
</p><p>It's assumed that for each of the arrays, elements (i0, i1, ..., in)
are all related. The function makes no test to ensure that, however.
</p><p>Note: While this version of tabular() will work when some arrays
have more dimensions than others, the collection of arrays must have
shapes that 'fit together'. This is case the arrays are limited in two ways. First the function is limited to <i>N</i> and <i>N+1</i> dimension arrays, nothing else, regardless of the value of <i>N</i>. Second, the arrays with <i>N+1</i> dimensions must all share the same named dimension for the 'additional dimension' and that named shred dimension will appear in the output Sequence as a new column.
</p>
<dl>
<dt>tabular(<i>array1</i>, <i>array2</i>, ..., <i>arrayN</i>)
</dt>
<dd>Returns a Sequence with N or N+1 columns
</dd>
</dl>
<h3><span class="mw-headline" id="roi.28.29"><span class="mw-headline-number">2.10</span> roi()</span></h3>
<p>Brief: Subset N arrays using index slicing information
</p><p>This function should be called with a series of array variables,
each of which are N-dimensions or greater, where the N common
dimensions should all be the same size. The intent of this function
is that a N-dimensional bounding box, provided in indicial space,
will be used to subset each of the arrays. There are other functions
that can be used to build these bounding boxes using values of
dataset variables - see bbox() and bbox_union(). Taken together,
the roi(), bbox() and bbox_union() functions can be used to subset
a collection of Arrays where some arrays are taken to be dependent
variables and others independent variables. The result is a subset
of 'discrete coverage' the collection of independent and dependent
variables define.
</p>
<dl>
<dt>roi(<i>array1</i>, <i>array2</i>, ..., <i>arrayN</i>, bbox(...))
</dt>
<dt>roi(<i>array1</i>, <i>array2</i>, ..., <i>arrayN</i>, bbox_union(bbox(...), bbox(...), ..., "union"))
</dt>
<dd>Subset <i>array1</i>, ..., using the bound box given as the last argument. Teh assumption is that the arrays will be the range variables of a coverage and that the bounding boxes will be computed using the range variables. See the <i>bbox()</i> and <i>bbox_union()</i> function descriptions.
</dd>
</dl>
<h3><span class="mw-headline" id="bbox.28.29"><span class="mw-headline-number">2.11</span> bbox()</span></h3>
<p>Brief: Return the bounding box for an array
</p><p>Given an N-dimensional Array of simple numeric types and two
minimum and maximum values, return the indices of a N-dimensional
bounding box. The indices are returned using an Array of
Structure, where each element of the array holds the name,
start index and stop index in fields with those names.
</p><p>It is up to the caller to make use of the returned values; the
array is not modified in any way other than to read in it's
values (and set the variable's read_p property).
</p><p>The returned Structure Array has the same name as the variable
it applies to, so that error messages can reference the source
variable.
</p>
<dl>
<dt>bbox(<i>array</i>, <i>min-value</i>, <i>max-value</i>)
</dt>
<dd>Given that <i>array</i> is an N-dimensional array, return a DAP Array with N elements. Each element is a DAP Structure with two fields, the indices corresponding to the first and last occurrence of the values <i>min-value</i> and <i>max-value</i>.
</dd>
</dl>
<h3><span class="mw-headline" id="bbox_union.28.29"><span class="mw-headline-number">2.12</span> bbox_union()</span></h3>
<p>Brief: Combine several bounding boxes, forming their union.
</p><p>This combines N BBox variables (Array of Structure) forming
either their union or intersection, depending on the last
parameter's value ("union" or "inter[section]").
</p><p>If the function is passed bboxes that have no intersection,
an exception is thrown. This is so that callers will know
why no data were returned. Otherwise, an empty response, while
correct, could be baffling to the client.
</p>
<dl>
<dt>bbox_union(bbox(<i>a1</i>, <i>min-value-1</i>, <i>max-value-1</i>), bbox(<i>a2</i>, <i>min-2</i>, <i>max-2</i>), ..., "union"|"intersection")
</dt>
<dd>Given 1 or more bounding box Array of Structures (as returned by the <i>bbox()</i> function) form their union or intersection and return that bounding box (using the same Array of Structures representation).
</dd>
</dl>
<h2><span class="mw-headline" id="Functions_Included_FreeForm_Module"><span class="mw-headline-number">3</span> Functions Included <i>FreeForm Module</i></span></h2>
<p>There are a number of date and time functions supported by the FreeForm server. 
</p><p>@TODO Add documentation for the functions
</p>
<h3><span class="mw-headline" id="Projection_functions"><span class="mw-headline-number">3.1</span> Projection functions</span></h3>
<h3><span class="mw-headline" id="Selection_functions"><span class="mw-headline-number">3.2</span> Selection functions</span></h3>




</div>
				<!-- end content -->
				<div class="visualClear"></div>
	</div>
</div></div>
</body></html>