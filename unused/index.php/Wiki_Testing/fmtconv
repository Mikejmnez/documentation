
<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<title>Wiki Testing/fmtconv - OPeNDAP Documentation</title>
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Wiki_Testing_fmtconv skin-monobook action-view">
<div id="globalWrapper">
<div id="column-content"><div id="content" class="mw-body-primary" role="main">
	
	
	<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Wiki Testing/fmtconv</span></h1>
	<div id="bodyContent" class="mw-body">
		<div id="siteSub">From OPeNDAP Documentation</div>
		<div id="contentSub"></div>
		

		<!-- start content -->
<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p><a href="../index.php/FreeForm" title="FreeForm">return to FreeForm</a>
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Format_Conversion"><span class="tocnumber">1</span> <span class="toctext">Format Conversion</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#newform"><span class="tocnumber">1.1</span> <span class="toctext">newform</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#chkform"><span class="tocnumber">1.2</span> <span class="toctext">chkform</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#readfile"><span class="tocnumber">1.3</span> <span class="toctext">readfile</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Creating_a_Binary_Archive"><span class="tocnumber">1.4</span> <span class="toctext">Creating a Binary Archive</span></a>
<ul>
<li class="toclevel-3 tocsection-6"><a href="#Simple_ASCII_to_Binary_Conversion"><span class="tocnumber">1.4.1</span> <span class="toctext">Simple ASCII to Binary Conversion</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Converting_to_Binary"><span class="tocnumber">1.4.2</span> <span class="toctext">Converting to Binary</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#Reconverting_to_Native_Format"><span class="tocnumber">1.4.3</span> <span class="toctext">Reconverting to Native Format</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Conversion_to_a_More_Portable_Binary"><span class="tocnumber">1.4.4</span> <span class="toctext">Conversion to a More Portable Binary</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="#Converting_to_Binary_Long"><span class="tocnumber">1.4.5</span> <span class="toctext">Converting to Binary Long</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#Reading_the_Binary_File"><span class="tocnumber">1.4.6</span> <span class="toctext">Reading the Binary File</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="#Including_a_Query"><span class="tocnumber">1.4.7</span> <span class="toctext">Including a Query</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-13"><a href="#File_Names_and_Context"><span class="tocnumber">1.5</span> <span class="toctext">File Names and Context</span></a>
<ul>
<li class="toclevel-3 tocsection-14"><a href="#.22Nonstandard.22_Data_File_Names"><span class="tocnumber">1.5.1</span> <span class="toctext">"Nonstandard" Data File Names</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#.22Nonstandard.22_Format_Description_File_Names"><span class="tocnumber">1.5.2</span> <span class="toctext">"Nonstandard" Format Description File Names</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-16"><a href="#Changing_ASCII_Formats"><span class="tocnumber">1.6</span> <span class="toctext">Changing ASCII Formats</span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Format_Conversion"><span class="mw-headline-number">1</span> Format Conversion</span></h1>
<p>The FreeForm ND utility program newform lets you convert data from one
format to another. This allows you to pass data to applications in the
format they require. You may also want to create binary archives for
efficient data storage and access. With newform, conversion of ASCII
data to binary format is straightforward. If you wish to read the data
in a binary file, you can convert it to ASCII with newform, or use the
interactive program readfile. You can also convert data from one ASCII
format to another ASCII format with newform.
</p>
<h2><span class="mw-headline" id="newform"><span class="mw-headline-number">1.1</span> <font color="green">newform</font></span></h2>
<p>The FreeForm ND-based program <font color="green">newform</font> is a general tool for changing the format ofa data file. The only required command line argument, if you use FreeForm ND naming conventions, is the name of the input data file.
The reformatted data is written to standard output (the screen) unless
you specify an output file. If you reformat to binary, you will
generally want to store the output in a file.
</p><p>You must create a format description file (or files) with format
descriptions for the data files involved in a conversion before you
can use <font color="green">newform</font> to perform the conversion. The standard
extension for format description files is <font color="green">.fmt</font>. If you do not
explicitly specify the format description file on the command line,
which is unnecessary if you use FreeForm ND naming conventions,
<font color="green">newform</font> follows the FreeForm ND search sequence to find a format
file.
</p><p>For details about FreeForm ND naming conventions and the search
sequence, see <a href="../index.php/Wiki_Testing/convs" title="Wiki Testing/convs">Conventions</a>.
</p><p>The <font color="green">newform</font> command has the following form:
</p><p><font color="green">newform</font> <i>input_file</i> [-f format_file] [-if-if input_format_file] [-of output_format_file]
</p><p>[-ft "title"] [-ift "title"] [-oft "title"] [-b local_buffer_size] [-c count] [-v var_file] [-q query_file] [-o output_file]
</p><p>For descriptions of the arguments, see <a href="../index.php/Wiki_Testing/convs" title="Wiki Testing/convs">Conventions</a>.
</p><p>If you want to convert an ASCII file to a binary file, and you follow
the FreeForm ND naming conventions, the command is simply:
</p>
<pre>
newform datafile.dat -o datafile.bin
</pre>
<p>where datafile is the file name of your choosing.
</p><p>If data files and format files are not in the current directory or in
the same directory, you can specify the appropriate path name.  For
example, if the input data file is not in the current directory, you
can enter:
</p>
<pre>
newform /path/datafile.dat -o datafile.bin
</pre>
<p><br />
To read the data in the resulting binary file, you can reformat back
to ASCII using the command:
</p>
<pre>
newform datafile.bin -o datafile.ext
</pre>
<p>or you can use the <font color="green">readfile</font> program, described in
<strong class="selflink">Format Conversion</strong>.
</p>
<h2><span class="mw-headline" id="chkform"><span class="mw-headline-number">1.2</span> <font color="green">chkform</font></span></h2>
<p>Though <font color="green">newform</font> is useful for checking data formats, it is
limited by requiring a format file to specify an output format.  Since
some OPeNDAP FreeForm ND applications (such as the OPeNDAP FreeForm handler) do not
require an output format, this is extra work for the dataset
administrator.  For these occasions, OPeNDAP FreeForm ND provides a simpler
format-checking program, called <font color="green">chkform</font>.
</p><p>The <font color="green">chkform</font> program attempts to read an ASCII file, using the
specified input format.  If the format allows the file to be read
</p><p>properly, <font color="green">chkform</font> says so.  However, if the input format
contains errors, or does not accurately reflect the contents of the
given data file, <font color="green">chkform</font> delivers an error message, and attempts
to provide a rudimentary diagnosis of the problem.
</p><p>You must create a format description file (or files) with format
descriptions for the data files involved before you can use
<font color="green">chkform</font> to chack the format.  As with <font color="green">newform</font>, the
standard extension for format description files is <font color="green">.fmt</font>. If you
do not explicitly specify the format description file on the command
line (unnecessary if you use FreeForm ND naming conventions)
<font color="green">chkform</font> follows the FreeForm ND search sequence to find a format
file.
</p><p>For details about FreeForm ND naming conventions and the search
sequence, see <a href="../index.php/Wiki_Testing/convs" title="Wiki Testing/convs">Conventions</a>.
</p><p>The <font color="green">chkform</font> command has the following form:
</p>
<pre>
chkform input_file [-if input_format_file] [-ift &quot;title&quot;] [-b local_buffer_size]
[-c count] [-q query_file] [-ol log_file] [-el error_log_file] [-ep]
</pre>
<p>Most of the arguments are described in
<a href="../index.php/Wiki_Testing/convs" title="Wiki Testing/convs">Conventions</a>.  The following are specific to
<font color="green">chkform</font>:
</p>
<dl>
<dt> -ol log_file</dt>
<dd> Puts a log of processing information into the specified <i>log_file</i>.
</dd>
</dl>
<dl>
<dt> -el error_log_file</dt>
<dd> Creates an error log file that contains whatever error messages are issued by <font color="green">chkform</font>.
</dd>
</dl>
<dl>
<dt> -ep&#160;</dt>
<dd> In normal operation, <font color="green">chkform</font> asks you to manually acknowledge each important error by typing something on the keyboard.  If you use this option, <font color="green">chkform</font> will not stop to prompt, but will continue processing until either the file is procesed, or there is an error preventing more processing.
</dd>
</dl>
<p><br />
As in the above examples, if you have an ASCII data file called
<font color="green">datafile.dat</font>, supposedly described in a format file called
<font color="green">datafile.fmt</font>, you can use <font color="green">chkform</font> like this:
</p>
<pre>
chkform datafile.dat
</pre>
<p>If processing is successful, you will see something like the
following:
</p>
<pre>


Welcome to Chkform release 4.2.3 -- an NGDC FreeForm ND application

(llmaxmin.fmt) ASCII_input_file_header  &quot;Latitude/Longitude Limits&quot;
File llmaxmin.dat contains 1 header record (71 bytes)
Each record contains 6 fields and is 71 characters long.

(llmaxmin.fmt) ASCII_input_data &quot;lat/lon&quot;
File llmaxmin.dat contains 10 data records (230 bytes)
Each record contains 3 fields and is 23 characters long.

100

No errors found (11 lines checked)
</pre>
<h2><span class="mw-headline" id="readfile"><span class="mw-headline-number">1.3</span> <font color="green">readfile</font></span></h2>
<p>FreeForm ND includes <font color="green">readfile</font>, a simple interactive binary file
reader. The program has one required command line argument, the name
of the file to be read. You do not have to write format descriptions
to use <font color="green">readfile</font>.
</p><p>The <font color="green">readfile</font> command has the following form:
</p><p><font color="green">readfile</font> <i>binary_data_file</i>
</p><p>When the program starts, it shows the available options, shown in
table 9.3. At the <font color="green">readfile</font> prompt, type
these option codes to view binary encoded values. (Pressing return
repeats the last option.)
</p>
 <center>
<pre>The <font color="green">readfile</font> program options
</pre>
<table border="1">
<tr>
<td> <font color="green">c</font> </td>
<td> char --- 1 byte character
</td></tr>
<tr>
<td> <font color="green">s</font> </td>
<td> short --- 2 byte signed integer
</td></tr>
<tr>
<td> <font color="green">l</font> </td>
<td> long --- 4 byte signed integer
</td></tr>
<tr>
<td> <font color="green">f</font> </td>
<td> float --- 4 byte single-precision floating point
</td></tr>
<tr>
<td> <font color="green">d</font> </td>
<td> double --- 8 byte double-precision floating point
</td></tr>
<tr>
<td> <font color="green">uc</font> </td>
<td> uchar --- 1 byte unsigned integer
</td></tr>
<tr>
<td> <font color="green">us</font> </td>
<td> ushort --- 2 byte unsigned integer
</td></tr>
<tr>
<td> <font color="green">ul</font> </td>
<td> ulong --- 4 byte unsigned integer
</td></tr>
<tr>
<td> <font color="green">b</font> </td>
<td> Toggle between "big-endian" and your machine's native byte
<p>order
</p>
</td></tr>
<font color="green">p</font> || Set new file position

<tr>
<td> <font color="green">P</font> </td>
<td>Show present file position and length
</td></tr>
<tr>
<td> <font color="green">h</font> </td>
<td> Display this help screen
</td></tr>
<tr>
<td> <font color="green">q</font> </td>
<td> Quit
</td></tr></table>
 </center>
<p>The options let you interactively read your way through the specified
binary file. The first position in the file is 0. You must type the
character(s) indicating variable type (e.g., us for unsigned short) to
view each value, so you need to know the data types of variables in
the file and the order in which they occur. If successive variables
are of the same type, you can press Return to view each value after
the first of that type.
</p><p>You can toggle the byte-order switch on and off by typing b. The
byte-order option is used to read a binary data file that requires
byte swapping. This is the case when you need cross-platform access to
a file that is not byte-swapped, for example, if you are on a Unix
machine reading data from a CD-ROM formatted for a PC. When the switch
is on, type s or l to swap short or long integers
respectively, or type f or d to swap floats or doubles.
The <font color="green">readfile</font> program does not byte swap the file itself (the
file is unchanged) but byte swaps the data values internally for
display purposes only.
</p><p>To go to another position in the file, type p. You are prompted
to enter the new file position in bytes. If, for example, each value
in the file is 4 bytes long and you type 16, you will be positioned at
the first byte of the fifth value. If you split fields (by not
repositioning at the beginning of a field), the results will probably
be garbage. Type P to find out your current position in the file
and total file length in bytes. Type q to exit from
<font color="green">readfile</font>.
</p><p>You can also use an input command file rather than entering commands
directly. In that case, the <font color="green">readfile</font> command has the following
form:
</p>
<pre>
readfile binary_data_file &lt; input_command_file
</pre>
<h2><span class="mw-headline" id="Creating_a_Binary_Archive"><span class="mw-headline-number">1.4</span> Creating a Binary Archive</span></h2>
<p>By storing data files in binary, you save disk space and make access
by applications more efficient. An ASCII data file can take two to
five times the disk space of a comparable binary data file. Not only
is there less information in each byte, but extra bytes are needed for
decimal points, delimiters, and end-of-line markers.
</p><p>It is very easy to create a binary archive using <font color="green">newform</font> as the
following examples show. The input data for these examples are in the
ASCII file <font color="green">latlon.dat</font> (shown below). They consist of 20 random
latitude and longitude values. The size of the file on a Unix system
is 460 bytes.
</p><p>Here is the <font color="green">latlon.dat</font> file:
</p>
<pre>
-47.303545 -176.161101
-0.928001    0.777265
-28.286662   35.591879
12.588231  149.408117
-83.223548   55.319598
54.118314 -136.940570
38.818812   91.411330
-34.577065   30.172129
27.331551 -155.233735
11.624981 -113.660611
77.652742  -79.177679
77.883119  -77.505502
-65.864879  -55.441896
-63.211962  134.124014
35.130219 -153.543091
29.918847  144.804390
-69.273601   38.875778
-63.002874   36.356024
35.086084  -21.643402
-12.966961   62.152266
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Simple_ASCII_to_Binary_Conversion"><span class="mw-headline-number">1.4.1</span> Simple ASCII to Binary Conversion</span></h3>
<p>In this example, you will use <font color="green">newform</font> to convert the ASCII data
file <font color="green">latlon.dat</font> into the binary file <font color="green">latlon.bin</font>. The input
and output data formats are described in <font color="green">latlon.fmt</font>.
</p><p>Here is the <font color="green">latlon.fmt</font> file:
</p>
<pre>
/ This is the format description file for data files latlon.bin
/ and latlon.dat. Each record in both files contains two fields,
/ latitude and longitude.

binary_data &quot;binary format&quot;
latitude 1 8 double 6
longitude 9 16 double 6

ASCII_data &quot;ASCII format&quot;
latitude 1 10 double 6
longitude 12 22 double 6
</pre>
<p>The binary and ASCII variables both have the same names. The binary
variable latitude occupies positions 1 to 8 and longitude occupies
positions 9-16. The corresponding ASCII variables occupy positions
1-10 and 12-22. Both the binary and ASCII variables are stored as
doubles and have a precision of 6.
</p>
<h3><span class="mw-headline" id="Converting_to_Binary"><span class="mw-headline-number">1.4.2</span> Converting to Binary</span></h3>
<p>To convert from an ASCII representation of the numbers in
<font color="green">latlon.dat</font> to a binary representation:
</p><p><br />
</p>
<ol>
<li>Change to the directory that contains the FreeForm ND example files.
</li>
<li>Enter the following command:  
</li>
</ol>
 <pre> newform latlon.dat -o latlon.bin  </pre>
<p>Because FreeForm ND filenaming conventions have been used,
<font color="green">newform</font> will locate and use <font color="green">latlon.fmt</font> for the
translation. The <font color="green">newform</font> program creates a new data file
(effectively a binary archive) called <font color="green">latlon.bin</font>. The size of
the archive file is 2/3 the size of <font color="green">latlon.dat</font>. Additionally,
the data do not have to be converted to machine-readable
representation by applications.
</p><p>There are two methods for checking the data in <font color="green">latlon.bin</font> to
make sure they converted correctly. You can reformat back to ASCII and
view the resulting file, or use <font color="green">readfile</font> to read
<font color="green">latlon.bin</font>.
</p>
<h3><span class="mw-headline" id="Reconverting_to_Native_Format"><span class="mw-headline-number">1.4.3</span> Reconverting to Native Format</span></h3>
<p>Use the following <font color="green">newform</font> command to reformat the binary data in
<font color="green">latlon.bin</font> to its native ASCII format:
</p>
<pre>
newform latlon.bin -o latlon.rf
</pre>
<p>The ASCII file <font color="green">latlon.rf</font> matches (but does not overwrite) the
original input file <font color="green">latlon.dat</font>. You can confirm this by using a
file comparison utility. The <font color="green">diff</font> command is generally available on
Unix platforms.
</p><p>To use <font color="green">diff</font> to compare the <font color="green">latlon</font> ASCII files, enter the
command:
</p>
<pre>
diff latlon.dat latlon.rf
</pre>
<p>The output should be something along these lines:
</p>
<pre>
Files are effectively identical.
</pre>
<p>Several implementations of the <font color="green">diff</font> utility don't print anything
if the two input files are identical.
</p><p><br />
</p>
<blockquote>NOTE: The <font color="green">diff</font> utility may detect a difference in other similar
<p>cases because FreeForm ND adds a leading zero in front of a decimal
and interprets a blank as a zero if the field is described as a
number. (A blank described as a character is interpreted as a
</p>
blank.) </blockquote>
<p><br />
</p><p><br />
</p>
<h3><span class="mw-headline" id="Conversion_to_a_More_Portable_Binary"><span class="mw-headline-number">1.4.4</span> Conversion to a More Portable Binary</span></h3>
<p>In this example, you will use <font color="green">newform</font> to reformat the latitude
and longitude values in the ASCII data file <font color="green">latlon.dat</font> into
binary longs in the binary file <font color="green">latlon2.bin</font>. The input and
output data formats are described in <font color="green">latlon2.fmt</font>.
</p><p>This is what's in <font color="green">latlon2.fmt</font>:
</p>
<pre>
/ This is the format description file for data files latlon.dat
/ and latlon2.bin. Each record in both files contains two fields,
/ latitude and longitude.

ASCII_data &quot;ASCII format&quot;
latitude 1 10 double 6
longitude 12 22 double 6

binary_data &quot;binary format&quot;
latitude 1 4 long 6
longitude 5 8 long 6
</pre>
<p>The ASCII and binary variables both have the same names. The ASCII
variable latitude occupies positions 1-10 and longitude occupies
positions 12-22. The ASCII variables are defined to be of type double.
The binary variables occupy four bytes each (positions 1-4 and 5-8)
and are of type long. The precision for all is 6.
</p>
<h3><span class="mw-headline" id="Converting_to_Binary_Long"><span class="mw-headline-number">1.4.5</span> Converting to Binary Long</span></h3>
<p>In the previous example, both the ASCII and binary variables were
defined to be doubles. Binary longs, which are 4-byte integers, may be
more portable across different platforms than binary doubles or
floats.
</p><p>To convert the ASCII data in <font color="green">latlon.dat</font> to binary longs:
</p><p><br />
</p>
<ol>
<li>Change to the directory that contains the FreeForm ND example
</li>
</ol>
<p>files.
</p>
<ol>
<li>Enter the following command:   <pre> newform latlon.dat -f latlon2.fmt -o latlon2.bin  </pre>
</li>
</ol>
<p>It creates the binary archive file <font color="green">latlon2.bin</font> with the 20
latitude and longitude values in <font color="green">latlon.dat</font> stored as binary
longs.
</p><p>This example duplicates one in <a href="../index.php/Wiki_Testing/dquick" title="Wiki Testing/dquick">Quick Start</a>. If you completed that
example, an error message will indicate that <font color="green">latlon2.bin</font> exists.
You can rename, move, or delete the existing file.
</p><p>The size of the archive file <font color="green">latlon2.bin</font> is about 1/3 the size
of <font color="green">latlon.dat</font>. Also, the data do not have to be converted to
machine representation by applications. The main tradeoff in achieving
savings in space and access time is that although binary longs are
more portable than binary doubles or floats, any binary representation
is less portable than ASCII.
</p>
<blockquote>CAUTION: There may be a loss of precision when input data of
type double is converted to long. </blockquote>
<p><br />
</p>
<h3><span class="mw-headline" id="Reading_the_Binary_File"><span class="mw-headline-number">1.4.6</span> Reading the Binary File</span></h3>
<p>Once again, you can use <font color="green">readfile</font> to check the data in the binary
archive you created.
</p><p><br />
</p>
<ol>
<li>Enter the following command:   <pre> readfile latlon2.bin  </pre>
</li>
<li>The data are stored as longs, so enter l to view each value (or press Return to view each value after the first).
</li>
<li>Enter q to quit <font color="green">readfile</font>.
</li>
</ol>
<p>If desired, you can enter the commands to <font color="green">readfile</font> from an input command file rather than directly from the command line. The example
command file <font color="green">latlon.in</font> is shown next.
</p><p>Here is <font color="green">latlon.in</font>:
</p>
<pre>
llllllp0 llPq
</pre>
<p>The 6 l's (l for <font color="green">long</font>) cause the first 6 values in the file to be
displayed. The sequence p0 causes a return to the top (position 0) of
the file. A position number (0) must be followed by a blank space. The
2 l's display the first two values again. The P displays the
current file position and length, and q closes <font color="green">readfile</font>.
</p><p>If you enter the following command:
</p>
<pre>
readfile latlon2.bin &lt; latlon.in
</pre>
<p>you should see the following output on the screen:
</p>
<pre>
long:  -47303545
long: -176161101
long:    -928001
long:     777265
long:  -28286662
long:   35591879
New File Position = 0
long:  -47303545
long: -176161101
File Position: 8       File Length: 160
</pre>
<p>The floating point numbers have been multiplied by 106, the precision
of the long variables in <font color="green">latlon2.fmt</font>.
</p>
<h3><span class="mw-headline" id="Including_a_Query"><span class="mw-headline-number">1.4.7</span> Including a Query</span></h3>
<p>You can use the query option (<font color="green">-q</font> <i>query_file</i>) to specify
exactly which records in the data file <font color="green">newform</font> should process.
The query file contains query criteria. Query syntax is summarized in
Appendix C.
</p><p>In this example, you will specify a query so that <font color="green">newform</font> will
reformat only those value pairs in <font color="green">latlon.dat</font> where latitude is
positive and longitude is negative into the binary file
<font color="green">llposneg.bin</font>. The input and output data formats are described in
<font color="green">latlon2.fmt</font>.
</p><p>The query criteria are specified in the following file, called
<font color="green">llposneg.qry</font>:
</p>
<pre>
[latitude] &gt; 0 &amp; [longitude] &lt; 0
</pre>
<p>To convert the desired data in <font color="green">latlon.dat</font> to binary and then
view the results:
</p><p><br />
</p>
<ol>
<li>Enter the following command:   <pre> newform latlon.dat -f latlon2.fmt -q llposneg.qry -o llposneg.bin  </pre>  The <font color="green">llposneg.bin</font> file now contains the positive/negative latitude/longitude pairs in binary form.
</li>
<li>To view the data, first convert the data in <font color="green">llposneg.bin</font> back to ASCII format:  newform llposneg.bin -f latlon2.fmt -o llposneg.dat
</li>
<li>Enter the appropriate command to display the data in <font color="green">llposneg.dat</font>, e.g. <font color="green">more</font>: The following output appears on the screen:  
</li>
</ol>
<pre> 
54.118314 -136.940570
27.331551 -155.233735
11.624981 -113.660611
77.652742  -79.177679
77.883119  -77.505502
35.130219 -153.543091
35.086084  -21.643402
</pre>  
<blockquote>NOTE: As demonstrated in the examples above, you can check the data in
<p>a binary file either by using <font color="green">readfile</font> or by converting the
</p>
data back to ASCII using <font color="green">newform</font> and then viewing it.  </blockquote>
<h2><span class="mw-headline" id="File_Names_and_Context"><span class="mw-headline-number">1.5</span> File Names and Context</span></h2>
<p>In the preceding examples, the read/write type (input or output) was
not included in the format descriptors (<font color="green">ASCII_data</font> and
<font color="green">binary_data</font>). FreeForm ND naming conventions were used, so
<font color="green">newform</font> can determine from the context which format should be
used for input and which for output. Consider the command:
</p>
<pre>
newform latlon.dat -o latlon.bin
</pre>
<p>The input file extension is <font color="green">.dat</font> and the output file extension
is <font color="green">.bin</font>. These extensions provide context indicating that ASCII
should be used as the input format and binary should be used as the
output format. The format description file that <font color="green">newform</font> will
look for is the file with the same name as the input file and the
extension <font color="green">.fmt</font>, i.e., <font color="green">latlon.fmt</font>.
</p><p>If you use the following command:
</p>
<pre>
newform latlon.bin
</pre>
<p>to translate the binary archive <font color="green">latlon.bin</font> back to ASCII,
<font color="green">newform</font> identifies the input format as binary and uses the ASCII
format for output. The ASCII data is written to the screen because an
output file was not specified.
</p><p>For information about FreeForm ND file name conventions, see
<a href="../index.php/Wiki_Testing/convs" title="Wiki Testing/convs">Conventions</a>.
</p>
<h3><span class="mw-headline" id=".22Nonstandard.22_Data_File_Names"><span class="mw-headline-number">1.5.1</span> "Nonstandard" Data File Names</span></h3>
<p>If you are working with data files that do not use FreeForm ND naming
conventions, you need to more explicitly define the context. For
example, the files <font color="green">lldat1.ll</font>, <font color="green">lldat2.ll</font>, <font color="green">lldat3.ll</font>,
<font color="green">lldat4.ll</font>, and <font color="green">lldat5.ll</font> all have latitude and longitude values in the ASCII format given in the format description file <font color="green">lldat.fmt</font>. If you wanted to archive these files in binary format, you could not use a command of the form used in the previous
examples, i.e., <font color="green">newform</font> <font color="green">datafile.dat</font> -o <font color="green">datafile.bin</font>
with <font color="green">datafile.fmt</font> as the default format description file.
</p><p>First, the ASCII data files do not have the extension <font color="green">.dat</font>,
which identifies them as ASCII files. Second, you would need five
separate format description files, all with the same content:
<font color="green">lldat1.fmt</font>, <font color="green">lldat2.fmt</font>, <font color="green">lldat3.fmt</font>,
<font color="green">lldat4.fmt</font>, and <font color="green">lldat5.fmt</font>. Creating the format
description file <font color="green">ll.fmt</font> solves both problems.
</p><p>Here is the <font color="green">ll.fmt</font> file:
</p>
<pre>
/ This is the format description file that describes latlon
/ data in files with the extension .ll

ASCII_input_data &quot;ASCII format for .ll latlon data&quot;
latitude 1 10 double 6
longitude 12 22 double 6

binary_output_data &quot;binary format for .ll latlon data&quot;
latitude 1 4 long 6
longitude 5 8 long 6
</pre>
<p>The name used for the format description file, <font color="green">ll.fmt</font>, follows the FreeForm ND convention that one format description file can be
utilized for multiple data files, all with the same extension, if the
format description file is named <font color="green">ext.fmt</font>. Also, the read/write type (input or output) is made explicit by including it in the format
descriptors <font color="green">ASCII_input_data</font> and <font color="green">binary_output_data</font>. This provides the context needed for FreeForm ND programs to determine which format to use for input and which for output.
</p><p>Use the following commands to produce binary versions of the ASCII
input files:
</p>
<pre>
newform lldat1.ll -o llbin1.ll
newform lldat2.ll -o llbin2.ll
newform lldat3.ll -o llbin3.ll
newform lldat4.ll -o llbin4.ll
newform lldat5.ll -o llbin5.ll
</pre>
<p>If you want to convert back to ASCII, you can switch the words input
and output in the format description file <font color="green">ll.fmt</font>. You could then use the following commands to convert back to native ASCII format with
output written to the screen:
</p>
<pre>
newform llbin1.ll
newform llbin2.ll
newform llbin3.ll
newform llbin4.ll
newform llbin5.ll
</pre>
<p>It is also possible to convert back to ASCII without switching the
read/write types input and output in <font color="green">ll.fmt</font>. You can specify input and output formats by title instead. In this case, you want to
use the output format in <font color="green">ll.fmt</font> as the input format and the input format in <font color="green">ll.fmt</font> as the output format. Use the following command to convert <font color="green">llbin1.ll</font> back to ASCII:
</p>
<pre>
newform &lt;font color='green'&gt;llbin1.ll&lt;/font&gt; -ift &quot;binary format for .ll latlon data&quot;

-oft &quot;ASCII format for .ll latlon data&quot;
</pre>
<p>Notice that <font color="green">newform</font> reports back the read/write type actually used. Since <font color="green">ASCII_input_data</font> was used as the output format, <font color="green">newform</font> reports it as <font color="green">ASCII_output_data</font>.
</p><p>Now assume that you want to convert the ASCII data file <font color="green">llvals.asc</font> (not included in the example file set) to the binary
file <font color="green">latlon3.bin</font>, and the input and output data formats are described in <font color="green">latlon.fmt</font>. The data file names do not provide the context allowing <font color="green">newform</font> to find <font color="green">latlon.fmt</font> by default, so you must include all file names on the command line:
</p>
<pre>
newform llvals.asc -f latlon.fmt -o latlon3.bin
</pre>
<h3><span class="mw-headline" id=".22Nonstandard.22_Format_Description_File_Names"><span class="mw-headline-number">1.5.2</span> "Nonstandard" Format Description File Names</span></h3>
<p>If you are using a format description file that does not follow
FreeForm ND file naming conventions, you must include its name on the
command line. Assume that you want to convert the ASCII data file
<font color="green">latlon.dat</font> to the binary file <font color="green">latlon.bin</font>, and the input
and output data formats are both described in <font color="green">llvals.frm</font> (not included in the example file set). The data file names follow FreeForm
ND conventions, but the name of the format description file does not,
so it will not be located through the default search sequence. Use the
following command to convert to binary:
</p>
<pre>
newform latlon.dat -f llvals.frm -o latlon.bin
</pre>
<p><br />
Suppose now that the input format is described in <font color="green">latlon.fmt</font> and
the output format in <font color="green">llvals.frm</font>. You do not need to explicitly specify the input format description file because it will be located
by default, but you must specify the output format description file
name. In this case, the command would be:
</p>
<pre>
newform latlon.dat -of llvals.frm -o latlon.bin
</pre>
<p>You can always unambiguously specify the names of format description
files and data files, whether or not their names follow FreeForm ND
conventions. Assume you want to look only at longitude values in
<font color="green">latlon.bin</font> and that you want them defined as integers (longs) which are right-justified at column 30. You will reformat the
specified binary data in <font color="green">latlon.bin</font> into ASCII data in
<font color="green">longonly.dat</font> and then view it. The input format is found in <font color="green">latlon.fmt</font>, the output format in <font color="green">longonly.fmt</font>.
</p><p>Here is <font color="green">longonly.fmt</font>:
</p>
<pre>
/ This is the format description file for viewing longitude as an
/ integer value right-justified at column 30.

ASCII_data &quot;ASCII output format, right-justified at 30&quot;
longitude 20 30 long 6
</pre>
<p>In this case, you have decided to look at the first 5 longitude values. Use the following command to unambiguously designate all files involved:
</p>
<pre>
newform latlon.bin -if latlon.fmt -of longonly.fmt -c 5
-o longonly.dat
</pre>
<p>When you view <font color="green">longonly.dat</font>, you should see the following 5 values:
</p>
<pre>

1         2         3         4
1234567890123456789012345678901234567890

-176161101
777265
35591879
149408117
55319598

</pre>
<h2><span class="mw-headline" id="Changing_ASCII_Formats"><span class="mw-headline-number">1.6</span> Changing ASCII Formats</span></h2>
<p>You may encounter situations where a specific ASCII format is
required, and your data cannot be used in its native ASCII format.
With <font color="green">newform</font>, you can easily reformat one ASCII format to
another. In this example, you will reformat California earthquake data
from one ASCII format to three other ASCII formats commonly used for
such data.The file <font color="green">calif.tap</font> contains data about earthquakes in
California with magnitudes &gt; 5.0 since 1980. The data were initially
distributed by NGDC on tape, hence the <font color="green">.tap</font> extension. The data
format is described in <font color="green">eqtape.fmt</font>:
</p><p>Here is the <font color="green">eqtape.fmt</font> file:
</p>
<pre>
/ This is the format description file for the NGDC .tap format,
/ which is used for data distributed on floppy disks or tapes.

ASCII_data &quot;.tap format&quot;
source_code 1 3 char 0
century 4 6 short 0
year 7 8 short 0
month 9 10 short 0
day 11 12 short 0
hour 13 14 short 0
minute 15 16 short 0
second 17 19 short 1
latitude_abs 20 24 long 3
latitude_ns 25 25 char 0
longitude_abs 26 31 long 3
longitude_ew 32 32 char 0
depth 33 35 short 0
magnitude_mb 36 38 short 2
MB 39 40 constant 0
isoseismal 41 43 char 0
intensity 44 44 char 0

/ The NGDC record check format includes
/ six flags in characters 45 to 50. These
/ can be treated as one variable to allow
/ multiple flags to be set in a single pass,
/ or each can be set by itself.

ngdc_flags 45 50 char 0
diastrophic 45 45 char 0
tsunami 46 46 char 0
seiche 47 47 char 0
volcanism 48 48 char 0
non_tectonic 49 49 char 0
infrasonic 50 50 char 0

fe_region 51 53 short 0
magnitude_ms 54 55 short 1
MS 56 57 char 0
z_h 58 58 char 0
cultural 59 59 char 0
other 60 60 char 0
magnitude_other 61 63 short 2
other_authority 64 66 char 0
ide 67 67 char 0
depth_control 68 68 char 0
number_stations_qual 69 71 char 0
time_authority 72 72 char 0
magnitude_local 73 75 short 2
local_scale 76 77 char 0
local_authority 78 80 char 0
</pre>
<p><br />
Three other formats used for California earthquake data are
hypoellipse, hypoinverse, and hypo71. Subsets of these formats are
described in the format description file <font color="green">hypo.fmt</font>. The format
descriptions include the parameters required by the AcroSpin program
that is distributed as part of the IASPEI Software Library (Volume 2).
AcroSpin shows 3D views of earthquake point data.
</p><p>Here is the <font color="green">hypo.fmt</font> file:
</p>
<pre>
/ This format description file describes subsets of the
/ hypoellipse, hypoinverse, and hypo71 formats.

ASCII_data &quot;hypoellipse format&quot;

year 1 2 uchar 0
month 3 4 uchar 0
day 5 6 uchar 0
hour 7 8 uchar 0
minute 9 10 uchar 0
second 11 14 ushort 2
latitude_deg_abs 15 16 uchar 0
latitude_ns 17 17 char 0
latitude_min 18 21 ushort 2
longitude_deg_abs 22 24 uchar 0
longitude_ew 25 25 char 0
longitude_min 26 29 ushort 2
depth 30 34 short 2
magnitude_local 35 36 uchar 1

ASCII_data &quot;hypoinverse format&quot;
year 1 2 uchar 0
month 3 4 uchar 0
day 5 6 uchar 0
hour 7 8 uchar 0
minute 9 10 uchar 0
second 11 14 ushort 2
latitude_deg_abs 15 16 uchar 0
latitude_ns 17 17 char 0
latitude_min 18 21 ushort 2
longitude_deg_abs 22 24 uchar 0
longitude_ew 25 25 char 0
longitude_min 26 29 ushort 2
depth 30 34 short 2
magnitude_local 35 36 uchar 1
number_of_times 37 39 short 0
maximum_azimuthal_gap 40 42 short 0
nearest_station 43 45 short 1
rms_travel_time_residual 46 49 short 2

ASCII_data &quot;hypo71 format&quot;
year 1 2 uchar 0
month 3 4 uchar 0
day 5 6 uchar 0
hour 8 9 uchar 0
minute 10 11 uchar 0
second 12 17 float 2
latitude_deg_abs 18 20 uchar 0
latitude_ns 21 21 char 0
latitude_min 22 26 float 2
longitude_deg_abs 27 30 uchar 0
longitude_ew 31 31 char 0
longitude_min 32 36 float 2
depth 37 43 float 2
magnitude_local 44 50 float 2
number_of_times 51 53 short 0
maximum_azimuthal_gap 54 57 float 0
nearest_station 58 62 short 1
rms_travel_time_residual 63 67 float 2
error_horizontal 68 72 float 1
error_vertical 73 77 float 1
s_waves_used 79 79 char 0
</pre>
<p><br />
The parameters from the California earthquake data in the NGDC format
needed for use with the AcroSpin program can be extracted and
converted using the following commands:
</p>
<pre>
newform calif.tap -if eqtape.fmt -of hypo.fmt

-oft &quot;hypoellipse format&quot; -o calif.he
newform calif.tap -if eqtape.fmt -of hypo.fmt

-oft &quot;hypoinverse format&quot; -o calif.hi
newform calif.tap -if eqtape.fmt -of hypo.fmt

-oft &quot;hypo71 format&quot; -o calif.h71
</pre>
<p>If you develop an application that accesses seismicity data in a
particular ASCII format, you need only to write an appropriate format
description file in order to convert NGDC data into the format used by
the application. This lets you make use of the data that NGDC provides
in a format that works for you.
</p>



</div>
				<!-- end content -->
				<div class="visualClear"></div>
	</div>
</div></div>
</body></html>